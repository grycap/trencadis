package trencadis.infrastructure.services.OntologiesServer.impl.wrapper.xmlOutputGetAllOntologies;/*******************************************************************  *********** CLASE GENERADA AUTOMATICAMENTE POR XMLWRAPPER **********  ********-----German Molto Martinez (gmolto@dsic.upv.es) -----*******  ********************************************************************/import org.w3c.dom.*;/** * Contiene los metodos que permiten obtener y cambiar la informacion de los * elementos <STRONG>ONTOLOGY </STRONG> del documento XML. */public class ONTOLOGY extends Wrapper {	/**	 * Crea un Wrapper que trabajara a partir de un elemento ONTOLOGY	 * 	 * @param e El elemento sobre el cual trabaja el Wrapper	 */	public ONTOLOGY(Element e) {		super(e);	}	/**	 * Obtiene el valor del atributo IDOntology	 * 	 * @return El valor del atributo IDOntology	 */	public String getAttr_IDOntology() {		try {			String unparsedValue = elem.getAttribute("IDOntology");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Establece un valor para el atributo IDOntology Si el atributo no existe,	 * lo crea	 * 	 * @param value El valor a introducir en el atributo	 */	public void setAttr_IDOntology(String value) {		try {			String unparsedValue = value;			elem.setAttribute("IDOntology", unparsedValue);		} catch (Exception e) {			e.printStackTrace();		}	}	/**	 * Obtiene el valor del atributo Description	 * 	 * @return El valor del atributo Description	 */	public String getAttr_Description() {		try {			String unparsedValue = elem.getAttribute("Description");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Establece un valor para el atributo Description Si el atributo no existe,	 * lo crea	 * 	 * @param value El valor a introducir en el atributo	 */	public void setAttr_Description(String value) {		try {			String unparsedValue = value;			elem.setAttribute("Description", unparsedValue);		} catch (Exception e) {			e.printStackTrace();		}	}	/**	 * Elimina el elemento ONTOLOGY y sus descendientes	 * 	 * @throws java.util.NoSuchElementException Si el atributo no se encuentra	 * @throws IllegalStateException Si el schema impide eliminar mas elementos	 */	public void delete() {		try {			elem.getParentNode().removeChild(elem);		} catch (Exception e) {			throw new java.util.NoSuchElementException(					"Se intenta eliminar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento xml_DICOM_SR_Template	 * 	 * @return El valor del elemento xml_DICOM_SR_Template	 */	public String get_xml_DICOM_SR_Template() {		try {			String xml = this.str_to_XML();			int ini = xml.indexOf("<DICOM_SR");			int fin = xml.indexOf("</DICOM_SR>");			xml = xml.substring(ini, fin + 11);			return xml;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento xml_DICOM_SR_Template Si el elemento no	 * existe, lo crea previamente	 * 	 * @param value El valor a establecer al elemento xml_DICOM_SR_Template	 * @throws IllegalArgumentException Si el valor incumple alguna de las restricciones del schema	 */	public void set_xml_DICOM_SR_Template(String value) {		String unparsedValue = value;		try {			setValueByTagName("xml_DICOM_SR_Template", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("xml_DICOM_SR_Template");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}}