package trencadis.middleware.wrapper.config;import org.w3c.dom.*;import java.io.*;import org.apache.xerces.parsers.DOMParser;import org.apache.xml.serialize.OutputFormat;import org.apache.xml.serialize.XMLSerializer;public class XmlWrapper extends Wrapper {	private String fileName;	Document doc = null;	private boolean inValidationMode;	/**	 * Creates a Wrapper for the XML document. It will be an entry point to the	 * document, as acess will be provided from here to the root element of the	 * XML document	 * 	 * @param filename	 *            The XML file name	 */	public XmlWrapper(File file, boolean inValidationMode) {		this.fileName = file.getAbsolutePath();		this.inValidationMode = inValidationMode;	}	/**	 * Creates a Wrapper for the XML document. It will be an entry point to the	 * document, as acess will be provided from here to the root element of the	 * XML document	 * 	 * @param filename	 *            The XML file name	 */	public XmlWrapper(String xmlDocument, boolean inValidationMode) {		try {			File f = File.createTempFile("XmlWrapper", ".xml");			this.fileName = f.getAbsolutePath();			FileOutputStream os = new FileOutputStream(f);			os.write(xmlDocument.getBytes());			os.close();		} catch (IOException ex) {			System.err.println("Unable to create file: " + fileName);		}		this.inValidationMode = inValidationMode;	}	/**	 * Starts the XML document parsing in validation mode (checks that the XML	 * document satisfies the Schema. If required, shows the errors Besides, it	 * obtains the root element of the document.	 * 	 * @param filename	 *            The XML file name.	 * @return false if an error occurs during parsing.	 */	public boolean wrap() {		return wrap(this.fileName, this.inValidationMode);	}	/**	 * Parses the XML document in validation mode (checks that the XML document	 * satisfies the Schema. If required, shows the errors Besides, it obtains	 * the root element of the document.	 * 	 * @param filename	 *            The XML file name.	 * @inValidationMode A boolean to indicate if the document should be read in	 *                   validation mode.	 * @return false if an error occurs during parsing.	 */	private boolean wrap(String filename, boolean inValidationMode) {		try {			DOMParser parser = new DOMParser();			if (inValidationMode) {				parser.setFeature("http://xml.org/sax/features/validation",						true);				parser.setFeature(						"http://apache.org/xml/features/validation/schema",						true);				parser.setProperty(						"http://apache.org/xml/properties/schema/external-noNamespaceSchemaLocation",						"trencadisConfig.xsd");			}			parser.setErrorHandler(new trencadis.middleware.wrapper.config.CustomErrorHandler());			parser.parse(filename);			doc = parser.getDocument();		} catch (Exception sxe) {			return false;		}		elem = doc.getDocumentElement();		return true;	}	/**	 * Obtains the current XML document (perhaps after the modifications you	 * made) in the form of a String	 * 	 * @return The current XML document as a String	 */	public String to_XMLString() {		String xmlCode = null;		File f = null;		try {			f = File.createTempFile("XmlWrapper", ".xml");			to_XML(f.getAbsolutePath());			xmlCode = fileToString(f.getAbsolutePath());		} catch (IOException ex) {			System.err.println(ex.getMessage());			return null;		}		return xmlCode;	}	/**	 * Obtains a String representation of a text file	 * 	 * @return The text file as a String	 */	private String fileToString(String textFilePath) throws IOException {		FileInputStream fis = new FileInputStream(textFilePath);		byte[] b = new byte[fis.available()];		fis.read(b);		fis.close();		return new String(b);	}	/**	 * Stores the changes in the same XML document	 */	public void to_XML() {		to_XML(fileName);	}	/**	 * Stores the changes in an XML document	 * 	 * @param filename	 *            The name of the file	 */	public void to_XML(String filename) {		try {			FileOutputStream out = new FileOutputStream(filename);			OutputFormat format = new OutputFormat(doc, "UTF-8", true);			XMLSerializer s = new XMLSerializer(out, format);			s.serialize(doc);		} catch (Exception e) {			e.printStackTrace();		}	}	/**	 * Verifies that all the changes produces to DOM satisfy the Schema	 * 	 * @return True If the current DOM is coherent with the schema. False if any	 *         modification violates the schema. A description of the error will	 *         be shown.	 */	public boolean validate() {		to_XML(fileName + ".tmp.xml");		if (!wrap(fileName + ".tmp.xml", true))			return false;		else			return true;	}	/************* M�todos de entrada al documento XML *************/	/**	 * Obtiene el valor del elemento PORT	 * 	 * @return El valor del elemento PORT	 */	public String get_PORT() {		try {			String unparsedValue = getValueByTagName("PORT");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento PORT Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento PORT	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_PORT(String value) {		String unparsedValue = value;		try {			setValueByTagName("PORT", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("PORT");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento PORT y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_PORT() {		try {			Element e = getElementByTagName("PORT");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento TMP_DIR	 * 	 * @return El valor del elemento TMP_DIR	 */	public String get_TMP_DIR() {		try {			String unparsedValue = getValueByTagName("TMP_DIR");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento TMP_DIR Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento TMP_DIR	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_TMP_DIR(String value) {		String unparsedValue = value;		try {			setValueByTagName("TMP_DIR", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("TMP_DIR");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento TMP_DIR y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_TMP_DIR() {		try {			Element e = getElementByTagName("TMP_DIR");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento USERCERT	 * 	 * @return El valor del elemento USERCERT	 */	public String get_USERCERT() {		try {			String unparsedValue = getValueByTagName("USERCERT");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento USERCERT Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento USERCERT	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_USERCERT(String value) {		String unparsedValue = value;		try {			setValueByTagName("USERCERT", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("USERCERT");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento USERCERT y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_USERCERT() {		try {			Element e = getElementByTagName("USERCERT");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento VOMSDIR	 * 	 * @return El valor del elemento VOMSDIR	 */	public String get_VOMSDIR() {		try {			String unparsedValue = getValueByTagName("VOMSDIR");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento VOMSDIR Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento VOMSDIR	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_VOMSDIR(String value) {		String unparsedValue = value;		try {			setValueByTagName("VOMSDIR", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("VOMSDIR");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento VOMSDIR y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_VOMSDIR() {		try {			Element e = getElementByTagName("VOMSDIR");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene un Wrapper a partir del elemento CONFIGURATION	 * 	 * @param value	 *            El Wrapper obtenido	 */	public CONFIGURATION get_CONFIGURATION() {		return new CONFIGURATION(elem);	}	/**	 * Obtiene un Wrapper a partir del elemento VOMS_PARAMETERS	 * 	 * @param value	 *            El Wrapper obtenido	 */	public VOMS_PARAMETERS get_VOMS_PARAMETERS() {		return new VOMS_PARAMETERS(elem);	}	/**	 * Obtiene el valor del elemento PATH_CATRUSTCERT	 * 	 * @return El valor del elemento PATH_CATRUSTCERT	 */	public String get_PATH_CATRUSTCERT() {		try {			String unparsedValue = getValueByTagName("PATH_CATRUSTCERT");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento PATH_CATRUSTCERT Si el elemento no existe, lo	 * crea previamente	 * 	 * @param value	 *            El valor a establecer al elemento PATH_CATRUSTCERT	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_PATH_CATRUSTCERT(String value) {		String unparsedValue = value;		try {			setValueByTagName("PATH_CATRUSTCERT", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("PATH_CATRUSTCERT");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento PATH_CATRUSTCERT y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_PATH_CATRUSTCERT() {		try {			Element e = getElementByTagName("PATH_CATRUSTCERT");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento URL_IIS_CENTRAL	 * 	 * @return El valor del elemento URL_IIS_CENTRAL	 */	public String get_URL_IIS_CENTRAL() {		try {			String unparsedValue = getValueByTagName("URL_IIS_CENTRAL");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento URL_IIS_CENTRAL Si el elemento no existe, lo	 * crea previamente	 * 	 * @param value	 *            El valor a establecer al elemento URL_IIS_CENTRAL	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_URL_IIS_CENTRAL(String value) {		String unparsedValue = value;		try {			setValueByTagName("URL_IIS_CENTRAL", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("URL_IIS_CENTRAL");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento URL_IIS_CENTRAL y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_URL_IIS_CENTRAL() {		try {			Element e = getElementByTagName("URL_IIS_CENTRAL");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene un Wrapper a partir del elemento MIDDLEWARE_PARAMETERS	 * 	 * @param value	 *            El Wrapper obtenido	 */	public MIDDLEWARE_PARAMETERS get_MIDDLEWARE_PARAMETERS() {		return new MIDDLEWARE_PARAMETERS(elem);	}	/**	 * Obtiene el valor del elemento HOSTDN	 * 	 * @return El valor del elemento HOSTDN	 */	public String get_HOSTDN() {		try {			String unparsedValue = getValueByTagName("HOSTDN");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento HOSTDN Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento HOSTDN	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_HOSTDN(String value) {		String unparsedValue = value;		try {			setValueByTagName("HOSTDN", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("HOSTDN");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento HOSTDN y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_HOSTDN() {		try {			Element e = getElementByTagName("HOSTDN");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento VO	 * 	 * @return El valor del elemento VO	 */	public String get_VO() {		try {			String unparsedValue = getValueByTagName("VO");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento VO Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento VO	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_VO(String value) {		String unparsedValue = value;		try {			setValueByTagName("VO", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("VO");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento VO y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_VO() {		try {			Element e = getElementByTagName("VO");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento USERKEY	 * 	 * @return El valor del elemento USERKEY	 */	public String get_USERKEY() {		try {			String unparsedValue = getValueByTagName("USERKEY");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento USERKEY Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento USERKEY	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_USERKEY(String value) {		String unparsedValue = value;		try {			setValueByTagName("USERKEY", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("USERKEY");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento USERKEY y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_USERKEY() {		try {			Element e = getElementByTagName("USERKEY");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento BASE_PATH	 * 	 * @return El valor del elemento BASE_PATH	 */	public String get_BASE_PATH() {		try {			String unparsedValue = getValueByTagName("BASE_PATH");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento BASE_PATH Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento BASE_PATH	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_BASE_PATH(String value) {		String unparsedValue = value;		try {			setValueByTagName("BASE_PATH", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("BASE_PATH");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento BASE_PATH y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_BASE_PATH() {		try {			Element e = getElementByTagName("BASE_PATH");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento HOST	 * 	 * @return El valor del elemento HOST	 */	public String get_HOST() {		try {			String unparsedValue = getValueByTagName("HOST");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento HOST Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento HOST	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_HOST(String value) {		String unparsedValue = value;		try {			setValueByTagName("HOST", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("HOST");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento HOST y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_HOST() {		try {			Element e = getElementByTagName("HOST");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene el valor del elemento VOMSES	 * 	 * @return El valor del elemento VOMSES	 */	public String get_VOMSES() {		try {			String unparsedValue = getValueByTagName("VOMSES");			String parsedValue = unparsedValue;			return parsedValue;		} catch (Exception e) {			e.printStackTrace();			return null;		}	}	/**	 * Asocia un valor al elemento VOMSES Si el elemento no existe, lo crea	 * previamente	 * 	 * @param value	 *            El valor a establecer al elemento VOMSES	 * @throws IllegalArgumentException	 *             Si el valor incumple alguna de las restricciones del schema	 */	public void set_VOMSES(String value) {		String unparsedValue = value;		try {			setValueByTagName("VOMSES", unparsedValue);		} catch (Exception e) { // Si no existe el elemento lo creamos			Element el = doc.createElement("VOMSES");			el.appendChild(doc.createTextNode(unparsedValue));			elem.appendChild(el);		}	}	/**	 * Elimina el elemento VOMSES y sus descendientes	 * 	 * @throws java.util.NoSuchElementException	 *             Si el atributo no se encuentra	 * @throws IllegalStateException	 *             Si el schema impide eliminar m�s elementos	 */	public void del_VOMSES() {		try {			Element e = getElementByTagName("VOMSES");			e.getParentNode().removeChild(e);		} catch (Exception ex) {			throw new java.util.NoSuchElementException(					" Se ha intentado borrar un elemento inexistente");		}	}	/**	 * Obtiene un Wrapper a partir del elemento INDEX_SERVICE_PARAMETERS	 * 	 * @param value	 *            El Wrapper obtenido	 */	public INDEX_SERVICE_PARAMETERS get_INDEX_SERVICE_PARAMETERS() {		return new INDEX_SERVICE_PARAMETERS(elem);	}}/** * Clase que proporciona un comportamiento personalizado frente a los errores al * analizar el documento XML. */class CustomErrorHandler implements org.xml.sax.ErrorHandler {	public void warning(org.xml.sax.SAXParseException exception)			throws org.xml.sax.SAXException {		System.out.println(">> Warning << " + "  Linea: "				+ exception.getLineNumber() + " " + "  Archivo:     "				+ exception.getSystemId() + " " + "  Mensaje: "				+ exception.getMessage());		throw new org.xml.sax.SAXException("Warning  ");	}	public void error(org.xml.sax.SAXParseException exception)			throws org.xml.sax.SAXException {		System.out.println(">> Error de Sintaxis << " + "  Linea: "				+ exception.getLineNumber() + " " + "  Archivo:     "				+ exception.getSystemId() + " " + "  Mensaje: "				+ exception.getMessage());		throw new org.xml.sax.SAXException("Error de Sintaxis");	}	public void fatalError(org.xml.sax.SAXParseException exception)			throws org.xml.sax.SAXException {		System.out.println(">> Error Fatal << " + "  Linea: "				+ exception.getLineNumber() + " " + "  Archivo:     "				+ exception.getSystemId() + " " + "  Mensaje: "				+ exception.getMessage());		throw new org.xml.sax.SAXException("Error fatal");	}}